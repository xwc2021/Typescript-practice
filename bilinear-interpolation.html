<html>

<head>

  <title>Canvas javascript api demo</title>
  <style type="text/css">
    canvas {
      border: 1px #000 solid;
    }
  </style>
</head>

<body>
  UV座標<input id="u" type="text" value="0.55" />
  <input id="v" type="text" value="0.35" />
  <input onclick="reBulid2()" type="button" value="reset" />
  <input onclick="moveRight();reBulid2();" type="button" value="右移" />
  <input onclick="moveDown();reBulid2();" type="button" value="下移" />
  <br />
  <canvas height="600" id="canvas" onclick="reBulid(new Point2D(event.offsetX,event.offsetY))" width="600">this browser
    does not support canvas...</canvas>

  <div>
    4個最近像素的內插結果
    <canvas height="30" id="canvas2" width="30">this browser does not support canvas...</canvas>
    <br />

  </div>
  <script type="text/javascript">
    var $ = function (id) {
      return document.getElementById(id);
    }

    function getValue(ui) {
      return ($(ui).value);
    }

    function setValue(ui, n) {
      $(ui).value = n;
    }

    function doScript() {
      var strValue = getValue("scriptStr");
      eval(strValue);

    }

    function RGB_Lerp(A, B, k) {
      var temp = new RGB(0, 0, 0);
      temp.r = Lerp(A.r, B.r, k);
      temp.g = Lerp(A.g, B.g, k);
      temp.b = Lerp(A.b, B.b, k);

      return temp;
    }

    function Lerp(a, b, k) {
      return a * (1.0 - k) + b * k;
    }

    RGB = function (pr, pg, pb) {
      this.r = pr;
      this.g = pg;
      this.b = pb;



      this.add = function (A) {
        var temp = new RGB(this.r + A.r, this.g + A.g, this.b + A.b);
        return temp
      }


      this.multiply = function (s) {
        var temp = new RGB(this.r * s, this.g * s, this.b * s);
        return temp
      }

      this.toString = function () {
        return "( " + this.r + " , " + this.g + " , " + this.b + " )";
      }
    }



    Point2D = function (px, py) {
      this.x = px;
      this.y = py;

      this.plus = function (p) {
        var temp = new Point2D(0, 0);
        temp.x = this.x + p.x;
        temp.y = this.y + p.y;

        return temp;
      }

      this.multiply = function (s) {
        var temp = new Point2D(0, 0);
        temp.x = this.x * s;
        temp.y = this.y * s;

        return temp;
      }

      this.toString = function () {
        return "( " + this.x + " , " + this.y + " )";
      }
    }

    window.onload = init;
    var canvas_width = 600;
    var canvas_height = 600;
    var row_count = 20;
    var colume_count = 20;
    var rect_w;
    var rect_h;
    var buffer;
    var buffer2;

    function drawUV() {
      var u = $("u").value;
      var v = $("v").value;

      texture2D(u, v);
    }

    function reBulid2() {
      var u = $("u").value;
      var v = $("v").value;

      Render();
    }

    function moveRight() {
      var u = parseFloat($("u").value);

      var grid_u = 1 / colume_count;
      u = accAdd(u, grid_u);

      $("u").value = u;
    }

    function moveDown() {
      var v = parseFloat($("v").value);

      var grid_v = 1 / row_count;
      v = accAdd(v, grid_v);

      $("v").value = v;
    }

    function reBulid(P) {
      var u = P.x / canvas_width;
      var v = P.y / canvas_height;

      $("u").value = u;
      $("v").value = v;

      Render();


    }


    //修正加法錯誤
    function accAdd(arg1, arg2) {
      //code from http://8st.blogspot.tw/2012/10/jsbug.html
      var r1, r2, m, c;
      try { r1 = arg1.toString().split(".")[1].length } catch (e) { r1 = 0 }
      try { r2 = arg2.toString().split(".")[1].length } catch (e) { r2 = 0 }
      c = Math.abs(r1 - r2);
      m = Math.pow(10, Math.max(r1, r2))
      if (c > 0) {
        var cm = Math.pow(10, c);
        if (r1 > r2) {
          arg1 = Number(arg1.toString().replace(".", ""));
          arg2 = Number(arg2.toString().replace(".", "")) * cm;
        }
        else {
          arg1 = Number(arg1.toString().replace(".", "")) * cm;
          arg2 = Number(arg2.toString().replace(".", ""));
        }
      }
      else {
        arg1 = Number(arg1.toString().replace(".", ""));
        arg2 = Number(arg2.toString().replace(".", ""));
      }
      return (arg1 + arg2) / m
    }

    //修正除法錯誤
    function accDiv(arg1, arg2) {
      //code from http://8st.blogspot.tw/2012/10/jsbug.html
      var t1 = 0, t2 = 0, r1, r2;
      try { t1 = arg1.toString().split(".")[1].length } catch (e) { }
      try { t2 = arg2.toString().split(".")[1].length } catch (e) { }
      with (Math) {
        r1 = Number(arg1.toString().replace(".", ""))
        r2 = Number(arg2.toString().replace(".", ""))
        return (r1 / r2) * pow(10, t2 - t1);
      }
    }

    function texture2D(u, v) {
      //先找出最近點
      var grid_u = 1 / colume_count;
      var grid_v = 1 / row_count;

      var half_grid_u = grid_u * 0.5;
      var half_grid_v = grid_v * 0.5;

      /*
      var temp_u_float = (u/half_grid_u);
      var temp_v_float = (v/half_grid_v);
      
      var temp_u = parseInt(u/half_grid_u);
      var temp_v = parseInt(v/half_grid_v);
      
      //剛好在1個點上
      if(temp_u_float==temp_u && temp_v_float==temp_v )
      {
       var nearest_point_u = parseInt(u/grid_u);
       var nearest_point_v = parseInt(v/grid_v);
       var P = new Point2D(nearest_point_u,nearest_point_v);
       drawPointByGridIndex(P);
       
       return;
      }
      */


      //以下是有4個鄰點的情況..
      var nearest_point_u_float = accDiv(u, grid_u);
      var nearest_point_v_float = accDiv(v, grid_v);

      var nearest_point_u = parseInt(nearest_point_u_float);
      var nearest_point_v = parseInt(nearest_point_v_float);

      var P = new Point2D(nearest_point_u, nearest_point_v);
      //alert(nearest_point_u+","+nearest_point_v);

      //在「最近點」格裡的local uv
      var s_u = u % grid_u;
      var s_v = v % grid_v;


      //再找出相鄰3點
      if (s_u >= half_grid_u && s_v >= half_grid_v)//相鄰3點在右下
      {
        //剛好整除時要做修正
        if (nearest_point_u_float == nearest_point_u)
          nearest_point_u = nearest_point_u - 1;

        if (nearest_point_v_float == nearest_point_v)
          nearest_point_v = nearest_point_v - 1;

        P = new Point2D(nearest_point_u, nearest_point_v);

        //alert("右下");
        var NE = new Point2D(P.x + 1, P.y);
        var SW = new Point2D(P.x, P.y + 1);
        var SE = new Point2D(P.x + 1, P.y + 1);
        //在4點內的uv
        var rectUV = new Point2D((s_u - half_grid_u) / grid_u, (s_v - half_grid_v) / grid_v);
        return Bilinear_Sampler(rectUV, P, NE, SW, SE);
      }
      else if (s_u <= half_grid_u && s_v >= half_grid_v)//相鄰3點在左下
      {
        //剛好整除時要做修正

        if (nearest_point_v_float == nearest_point_v)
          nearest_point_v = nearest_point_v - 1;

        P = new Point2D(nearest_point_u, nearest_point_v);


        //alert("左下");
        var NW = new Point2D(P.x - 1, P.y);
        var SW = new Point2D(P.x - 1, P.y + 1);
        var SE = new Point2D(P.x, P.y + 1);
        //在4點內的uv
        var rectUV = new Point2D((s_u + half_grid_u) / grid_u, (s_v - half_grid_v) / grid_v);
        return Bilinear_Sampler(rectUV, NW, P, SW, SE);
      }
      else if (s_u <= half_grid_u && s_v <= half_grid_v)//相鄰3點在左上
      {
        //alert("左上");
        var NW = new Point2D(P.x - 1, P.y - 1);
        var NE = new Point2D(P.x, P.y - 1);
        var SW = new Point2D(P.x - 1, P.y);
        //在4點內的uv
        var rectUV = new Point2D((s_u + half_grid_u) / grid_u, (s_v + half_grid_v) / grid_v);
        return Bilinear_Sampler(rectUV, NW, NE, SW, P);
      }
      else if (s_u >= half_grid_u && s_v <= half_grid_v)//相鄰3點在右上
      {
        //剛好整除時要做修正
        if (nearest_point_u_float == nearest_point_u)
          nearest_point_u = nearest_point_u - 1;

        P = new Point2D(nearest_point_u, nearest_point_v);

        //alert("右上");
        var NW = new Point2D(P.x, P.y - 1);
        var NE = new Point2D(P.x + 1, P.y - 1);
        var SE = new Point2D(P.x + 1, P.y);
        //在4點內的uv
        var rectUV = new Point2D((s_u - half_grid_u) / grid_u, (s_v + half_grid_v) / grid_v);
        return Bilinear_Sampler(rectUV, NW, NE, P, SE);
      }
    }

    function Bilinear_Sampler(rectUV, NW, NE, SW, SE) {
      /*
      alert(rectUV.toString());
      alert(NW.toString());
      alert(NE.toString());
      alert(SW.toString());
      alert(SE.toString());
      */

      //畫4個鄰近點
      drawPointByGridIndex(NW);
      drawPointByGridIndex(NE);
      drawPointByGridIndex(SW);
      drawPointByGridIndex(SE);
      drawRect(NW);
      drawPointByRectUV(NW, rectUV);

      //對4個點顏色作內插
      var NWcolor = getBuffer(NW.x, NW.y);
      var NEcolor = getBuffer(NE.x, NE.y);
      var SWcolor = getBuffer(SW.x, SW.y);
      var SEcolor = getBuffer(SE.x, SE.y);



      var topRGB = RGB_Lerp(NWcolor, NWcolor, rectUV.x);
      var downRGB = RGB_Lerp(SWcolor, SEcolor, rectUV.x);

      var middleRGB = RGB_Lerp(topRGB, downRGB, rectUV.y);

      var ctx = $('canvas2').getContext('2d');
      ctx.globalCompositeOperation = 'source-over';
      ctx.fillStyle = convert(middleRGB);
      //alert(convert(middleRGB));
      ctx.fillRect(0, 0, 30, 30);
    }

    //畫出uv點
    function drawPointByRectUV(P, rectUV) {
      var ctx = $('canvas').getContext('2d');
      ctx.globalCompositeOperation = 'source-over';

      ctx.beginPath();
      ctx.fillStyle = 'rgba(0,255,0,1)';

      var targetP = new Point2D((P.x + 0.5) * rect_w + rect_w * rectUV.x, (P.y + 0.5) * rect_h + rect_h * rectUV.y);
      var r = 6;
      ctx.fillRect(targetP.x - 0.5 * r, targetP.y - 0.5 * r, r, r);
      ctx.stroke();
    }

    function drawRect(P) {
      var ctx = $('canvas').getContext('2d');
      ctx.globalCompositeOperation = 'source-over';

      ctx.beginPath();
      ctx.strokeStyle = 'rgba(255,255,0,1)';
      ctx.rect((P.x + 0.5) * rect_w, (P.y + 0.5) * rect_h, rect_w, rect_h);
      ctx.stroke();
    }

    function drawPointByGridIndex(P) {
      var ctx = $('canvas').getContext('2d');
      ctx.globalCompositeOperation = 'source-over';

      ctx.beginPath();
      ctx.fillStyle = 'rgba(255,255,0,1)';
      var r = 6;
      ctx.fillRect((P.x + 0.5) * rect_w - 0.5 * r, (P.y + 0.5) * rect_h - 0.5 * r, r, r);
      ctx.stroke();
    }

    function reset() {
      rect_w = canvas_width / colume_count;
      rect_h = canvas_height / row_count;

      buffer = new Array(rect_w);
      buffer2 = new Array(rect_w);
      for (var x = 0; x < rect_w; x++) {
        buffer[x] = new Array(rect_h);
        buffer2[x] = new Array(rect_h);
      }
      for (var x = 0; x < rect_w; x++)
        for (var y = 0; y < rect_h; y++) {
          buffer[x][y] = new RGB(0, 0, 0);
          buffer2[x][y] = new RGB(0, 0, 0);
        }
    }


    function init() {
      reset();
      drawStar();
      Render();
    }


    function Render() {
      drawBuffer();
      drawUV();
    }


    function drawStar() {
      var it = 5;
      var delta = 2 * Math.PI / it;
      var R = 9;
      var center = new Point2D(10, 10);


      var startTheda = -Math.PI / 3;

      //畫圓
      /*
      for(var i=0;i<it;i++)
      {
      var nowX = parseInt(center.x+R*Math.cos(startTheda+delta*i));
      var nowY = parseInt(center.y+R*Math.sin(startTheda+delta*i));
      
      var nextX = parseInt(center.x+R*Math.cos(startTheda+delta*(i+1)));
      var nextY = parseInt(center.y+R*Math.sin(startTheda+delta*(i+1)));
      
      drawLineWrapper(new Point2D(nowX,nowY),new Point2D(nextX,nextY));
      }
      */

      //畫星星
      var k = 0;
      for (var i = 0; i < it; i++) {
        var nowX = parseInt(center.x + R * Math.cos(startTheda + delta * k));
        var nowY = parseInt(center.y + R * Math.sin(startTheda + delta * k));

        var nextX = parseInt(center.x + R * Math.cos(startTheda + delta * (k + 2)));
        var nextY = parseInt(center.y + R * Math.sin(startTheda + delta * (k + 2)));

        //alert(nowX+","+nowY+" "+nextX+","+nextY);
        drawLineWrapper(new Point2D(nowX, nowY), new Point2D(nextX, nextY));
        k = k + 2;
      }
    }

    function dot(t0, t1) {
      return t0.r * t1.r + t0.g * t1.g + t0.b * t1.b;
    }



    function getDistance(px, py, px2, py2) {
      var dir = new Point2D((px - px2), (py - py2));
      var R = dir.length();
      return R;
    }

    function checkIndex(x, y) {
      if (x >= 0 && x < colume_count && y >= 0 && y < row_count)
        return true;
      else return false;
    }

    function isOverPositive(x, y, endX, endY) {
      if (y > endY || x > endX)
        return true;
      else
        return false;
    }

    function isOverNegotive(x, y, endX, endY) {
      if (y > endY || x < endX)
        return true;
      else
        return false;
    }

    function drawLineWrapper(t0, t1) {
      //從上往下畫
      if (t0.y < t1.y)
        drawLine(t0, t1);
      else if (t1.y < t0.y)
        drawLine(t1, t0);
      else //水平線
      {
        //從左往右畫
        if (t0.x < t1.x)
          drawLine(t0, t1);
        else if (t1.x < t0.x)
          drawLine(t1, t0);
      }
    }

    //超過邊界就使用邊界值
    function getBuffer(x, y) {
      if (x < 0) {
        if (y < 0)
          return buffer[0][0];
        else
          return buffer[0][y];
      }

      if (y < 0) {
        if (x < 0)
          return buffer[0][0];
        else
          return buffer[x][0];
      }
      if (x >= colume_count) {
        if (y >= row_count)
          return buffer[colume_count - 1][row_count - 1];
        else
          return buffer[colume_count - 1][y];
      }
      if (y >= row_count) {
        if (x >= colume_count)
          return buffer[colume_count - 1][row_count - 1];
        else
          return buffer[x][row_count - 1];
      }

      return buffer[x][y];
    }


    function getPenColor() {
      return new RGB(1, 0, 0);
    }


    function drawLine(one, two) {
      var fromX = one.x;
      var fromY = one.y;
      var now = new Point2D(fromX, fromY);
      var toX = two.x;
      var toY = two.y;
      var parent = (toY - fromY);
      var child = (toX - fromX);

      var step = 100;
      if (parent == 0)//horizon
      {
        for (var i = 1; i < step; i++) {
          //左畫到右
          now.x = now.x + 1;
          if (!checkIndex(now.x, now.y))
            break;

          if (now.x > toX)
            break;

          buffer[now.x][now.y] = getPenColor();
        }
        return;
      }

      if (child == 0)//vertical
      {
        for (var i = 1; i < step; i++) {
          //上畫到下
          now.y = now.y + 1;
          if (!checkIndex(now.x, now.y))
            break;

          if (now.y > toY)
            break;

          buffer[now.x][now.y] = getPenColor();
        }
        return;
      }

      var ratio = child / parent;
      var abs_r = Math.abs(ratio);

      if (checkIndex(intX, now.y))
        buffer[now.x][now.y] = 1;

      if (ratio > 0) {
        if (abs_r <= 1) {
          for (var i = 1; i < step; i++) {
            now.y = now.y + 1;
            now.x = now.x + abs_r;
            var intX = parseInt(now.x);
            if (!checkIndex(intX, now.y))
              break;

            if (isOverPositive(now.x, now.y, toX, toY))
              break;

            buffer[intX][now.y] = getPenColor();
          }
        }
        else if (abs_r > 1) {
          for (var i = 1; i < step; i++) {
            now.y = now.y + 1 / abs_r;
            now.x = now.x + 1;
            var intY = parseInt(now.y);
            if (!checkIndex(now.x, intY))
              break;

            if (isOverPositive(now.x, now.y, toX, toY))
              break;
            buffer[now.x][intY] = getPenColor();
          }
        }
      }
      else if (ratio < 0) {
        if (abs_r <= 1) {
          for (var i = 1; i < step; i++) {
            now.y = now.y + 1;
            now.x = now.x - abs_r;
            var intX = parseInt(now.x);
            if (!checkIndex(intX, now.y))
              break;

            if (isOverNegotive(now.x, now.y, toX, toY))
              break;
            buffer[intX][now.y] = getPenColor();
          }
        }
        else if (abs_r > 1) {
          for (var i = 1; i < step; i++) {
            now.y = now.y + 1 / abs_r;
            now.x = now.x - 1;
            var intY = parseInt(now.y);
            if (!checkIndex(now.x, intY))
              break;

            if (isOverNegotive(now.x, now.y, toX, toY))
              break;
            buffer[now.x][intY] = getPenColor();
          }
        }
      }

    }



    function convert(c) {
      return 'rgba(' + parseInt(255 * (c.r)) + ',' + parseInt(255 * (c.g)) + ',' + parseInt(255 * (c.b)) + ',1)';
    }

    function drawBuffer() {
      var ctx = $('canvas').getContext('2d');
      ctx.clearRect(0, 0, 600, 600);


      for (var y = 0; y < row_count; y++) {
        for (var x = 0; x < colume_count; x++) {
          ctx.beginPath();
          ctx.fillStyle = convert(buffer[x][y]);
          var r = 1;
          ctx.fillRect(x * rect_w + r, y * rect_h + r, rect_w - r, rect_h - r);
          ctx.stroke();
        }
      }


    }

  </script>
</body>

</html>